import {spinnerSignal} from "@stores/viewer/loader";
import * as OBC from "@thatopen/components";
import * as THREE from "three";
import {LogLevel} from "web-ifc";

interface GeometriesStreaming {
  assets: {
    id: number;
    geometries: {
      color: number[];
      geometryID: number;
      transformation: number[];
    }[];
  }[];

  geometries: {
    [id: number]: {
      boundingBox: {[id: number]: number};
      hasHoles: boolean;
      geometryFile?: string;
    };
  };
}

/**
 *
 */
export class IfcTilerComponent extends OBC.Component implements OBC.Disposable {
  //1 attribute
  /**
   * A unique identifier for the component.
   * This UUID is used to register the component within the Components system.
   */
  static readonly uuid = "245d14fc-e534-4b5e-bdef-c1ca3e6bb734" as const;
  private static readonly wasm = {
    path: "https://unpkg.com/web-ifc@0.0.56/",
    absolute: true,
    LogLevel: LogLevel.LOG_LEVEL_OFF,
  };
  enabled = false;
  readonly onDisposed: OBC.Event<any> = new OBC.Event();

  //2 constructor
  /**
   *
   * @param components
   */
  constructor(components: OBC.Components) {
    super(components);
    this.components.add(IfcTilerComponent.uuid, this);
  }
  //3 method
  async dispose() {
    this.onDisposed.trigger(this);
    this.onDisposed.reset();
    console.log("disposed IfcTilerComponent");
  }

  async streamIfcFile(ifcArrayBuffer: Uint8Array, fileName: string) {
    if (!this.enabled) throw new Error("This class was not enabled!");
    const tiler = this.components.get(OBC.IfcGeometryTiler);
    tiler.settings.wasm = IfcTilerComponent.wasm;
    tiler.settings.minGeometrySize = 20;
    tiler.settings.minAssetsSize = 1000;
    tiler.onGeometryStreamed.reset();
    tiler.onAssetStreamed.reset();
    tiler.onIfcLoaded.reset();
    tiler.onProgress.reset();

    const before = performance.now();

    let files: {name: string; bits: (Uint8Array | string)[]}[] = [];
    let geometriesData: OBC.StreamedGeometries = {};
    let geometryFilesCount = 1;

    tiler.onGeometryStreamed.add((geometry) => {
      const {buffer, data} = geometry;
      const bufferFileName = `small.ifc-processed-geometries-${geometryFilesCount}`;
      for (const expressID in data) {
        const value = data[expressID];
        value.geometryFile = bufferFileName;
        geometriesData[expressID] = value;
      }
      files.push({name: bufferFileName, bits: [buffer]});
      geometryFilesCount++;
    });

    /* MD
        One of the most important things to keep in mind is that the event we just setup will get fired as many times as per the "chunk" data generated by the converted. Simply put, the event will get fired several times ⏲ and per each time we will produce one file data that is stored in the `geometryFiles` array. Later on, we will download the geometry files ⏬.
      
        :::note
      
        As you see, `geometriesData` is not being stored as a file to be downloaded. The reason is because that is part of the information we need to create the entry JSON file 🚀.
      
        :::
      
        Nice! Let's go with the second event that will give us more information to create the required files:
        */

    let assetsData: OBC.StreamedAsset[] = [];

    tiler.onAssetStreamed.add((assets) => {
      assetsData = [...assetsData, ...assets];
    });

    /* MD
        This one is easier as the event doesn't produce binary data, but information we need to create the JSON file. 
        
        :::note Are you familiar with Fragments?
        
        If you're familiar with That Open Engine (our libraries), you should recall fragments. Fragments are just a fancy word we use to refer to ThreeJS geometry efficiently created from IFC files which are the things you end up see in the viewer... one IFC file is usually composed of many fragments and all of them are grouped in a FragmentsGroup, which is the final processed IFC model.
        
        :::
        
        Why do we remind you about FragmentsGroup? Because streaming also works with them! So yes, when you convert an IFC to tiles, the converter also creates a FragmentsGroup in the background, and that information is extremely important for the streamer in order to display the streamed file as everything gets grouped there. So, there is another event that gives you the FragmentsGroup binary data and we also need to create a file with that information.
        */

    tiler.onIfcLoaded.add((groupBuffer) => {
      files.push({
        name: "small.ifc-processed-global",
        bits: [groupBuffer],
      });
      const onIfcLoaded = performance.now() - before;
      console.log("onIfcLoaded", onIfcLoaded);
    });

    tiler.onProgress.add((progress) => {
      if (progress !== 1) return;

      setTimeout(async () => {
        const processedData = {
          geometries: geometriesData,
          assets: assetsData,
          globalDataFileId: "small.ifc-processed-global",
        };
        files.push({
          name: "small.ifc-processed.json",
          bits: [JSON.stringify(processedData)],
        });
        // send to server
        // await downloadFilesSequentially(files);
        assetsData = [];
        geometriesData = {};
        files = [];
        geometryFilesCount = 1;
        spinnerSignal.value = false;
        const onProgress = performance.now() - before;
        console.log("onProgress", onProgress);
      });
    });

    await tiler.streamFromBuffer(ifcArrayBuffer);
  }
}
